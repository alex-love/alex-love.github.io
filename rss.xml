<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Alex Love's Personal Website]]></title><description><![CDATA[A small website for my personal portfolio and reflections on my learning.]]></description><link>http://alex-love.github.io</link><generator>RSS for Node</generator><lastBuildDate>Mon, 24 Jun 2019 20:48:26 GMT</lastBuildDate><item><title><![CDATA[How I intend to use my website]]></title><description><![CDATA[Overall GoalI want this website to be a place where I can reflect on my projects, but also host my projects. My idea is that some of the…]]></description><link>http://alex-love.github.io/my-plans/</link><guid isPermaLink="false">http://alex-love.github.io/my-plans/</guid><pubDate>Mon, 24 Jun 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Overall Goal&lt;/h1&gt;
&lt;p&gt;I want this website to be a place where I can reflect on my projects, but also host my projects. My idea is that some of the stuff I want to learn will be cooked into this website/blog itself. For example, I want to create a few microservices that I can use to build my site (in terms of continous deployment).&lt;/p&gt;
&lt;h3&gt;I should be using continous deployment&lt;/h3&gt;
&lt;p&gt;I’ll be honest and say that I’m not 100% certain what this means. I know that the idea behind websites like this, being 100% stored in a single repository is that I have a &lt;code class=&quot;language-text&quot;&gt;single source of truth&lt;/code&gt; in terms of the contents of this website. Anytime a change is made in my repository, that means that my site needs to be rebuilt and redeployed. This means that somewhere, a server needs to be listening/have a webhook to my git repo. When a change is detected, or more realistically, when the webhook fires off a request (I think that’s how it works), then my server knows to run some automated tests, and if those tests pass, to build it and redeploy it.&lt;/p&gt;
&lt;h4&gt;This is not how I do it&lt;/h4&gt;
&lt;p&gt;Currently, when I make a change to my website I use an easily automatable workflow. I make the changes on my development server, then I run a build command and use a gh-pages npm command to push my changes to my repository. This is mostly for adding blogposts, as I haven’t really added much functionality lately (more on that later).&lt;/p&gt;
&lt;h4&gt;More about blog posts&lt;/h4&gt;
&lt;p&gt;At some point I’d like to set up my own headless cms for Gatsby. I’ll probably use Wordpress, not because I like it but because clients understand how to use it.&lt;/p&gt;
&lt;h5&gt;How I currently do blog posts&lt;/h5&gt;
&lt;p&gt;Originally I would create a ‘draft’ by having my published variable be set to false. I just assumed this would work, but found that when I ran the build and deployed it, my draft posts would still be public. I obviously didn’t want this so I started storing my blog posts in another repository and then just moving them over to my main repo and rebuilding as necessary.&lt;/p&gt;
&lt;p&gt;This is obviously not the most efficient workflow, so I’d like to improve it. Services like Netflify are great for this, but I want to learn how to do it myself. It’s fine for something that I need to get working immediately, but what if it breaks? I have no idea how it works and I’m completely dependent on a third-party service for something that I already know how to do, although not the most efficiently.&lt;/p&gt;
&lt;h2&gt;Back to the Goal&lt;/h2&gt;
&lt;p&gt;Ultimately the goal is learning, understanding, reflecting, and possibly teaching. While using something like Gatsby is nice, I understand that I really should understand some core inner workings a little better. Using frameworks like react is nice, but I’m always working to become better acquainted with the core technologies. I mostly use Gatsby as a way to maintain a blog that I know should work. I also use it to keep learning/using react and other current technologies, although I don’t use them outside of this very often.&lt;/p&gt;
&lt;p&gt;For my personal stack those are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Frontend: javascript, html, css&lt;/li&gt;
&lt;li&gt;Backend: python, javascript(Node)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Some projects I’m working on/plan on working on&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;python microservices (image processing, speech processing, basic data stuff etc… fun stuff)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;apis to expose this functionality for my frontend&lt;/li&gt;
&lt;li&gt;Reverse proxy in nginx for some of my other backend stuff&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Design process&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I’m trying to get better at design/planning before doing a project&lt;/li&gt;
&lt;li&gt;While I can throw stuff together, it ends up taking more time&lt;/li&gt;
&lt;li&gt;This also allows me to write more custom frontend code and not default to bootstrapy stuff as much (not dependent on those, just saves time)&lt;/li&gt;
&lt;li&gt;This also makes for better posts/reflection, as I will have an original design to compare to my final product&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;data science&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I’m slowly been working to improve my data skills in python&lt;/li&gt;
&lt;li&gt;This includes the usual… numpy, pandas, scikit-learn, matplotlib&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Current changes to this site&lt;/h3&gt;
&lt;p&gt;I know this post has been random and incoherrent. That’s okay though, this is mostly just a reference for myself. I don’t really think many, if any are reading this. That being said, here’s what I’m currently working on for my site:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Portfolio Element Redesign&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Have max description length&lt;/li&gt;
&lt;li&gt;Create picture/logo snippet of project&lt;/li&gt;
&lt;li&gt;Implement card style design with css modules&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Deviation From This Theme Starter&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This blog comes from a starter theme… I’m going to make it more unique.&lt;/li&gt;
&lt;li&gt;Goal is that I mostly just used the blog functionality as a starting point and it looks less like the starter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;I’d like to add to create a custom cms so I can edit my markdown blog posts and any other data I use (json resume etc…).&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[This Website and Hosting with Github pages]]></title><description><![CDATA[Why GatsbyThe idea of static site generators have been of interest to me for a while. After working with/in Wordpress for a while, I really…]]></description><link>http://alex-love.github.io/this-website/</link><guid isPermaLink="false">http://alex-love.github.io/this-website/</guid><pubDate>Fri, 10 May 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;Why Gatsby&lt;/h3&gt;
&lt;p&gt;The idea of static site generators have been of interest to me for a while. After working with/in Wordpress for a while, I really wanted to get as far away from it as I could. Nothing against Wordpress, it has a time and a place, I just needed a break. I chose Gatsby because it allowed me to continue working with React and with additional technologies such as Graphql. It’s also nice to get the performance and security benefit that comes from using a static site generator. In general it’s just much more convenient for someone like me because I can serve my websites/apps without the overhead of an active backend (cheaper too).&lt;/p&gt;
&lt;h4&gt;Process&lt;/h4&gt;
&lt;p&gt;I started this website from a popular blog starter theme. The main changes I made were adding my resume and project section.&lt;/p&gt;
&lt;h4&gt;JSON Resume&lt;/h4&gt;
&lt;p&gt;I thought it would be cool to have my resume data easily editable and queryable. To do this, I decided to store my resume data is a JSON file. Through the power of Gatsby, Graphql, and a JSON plugin, I could easily query and manipulate my resume data.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;dataJson{
        work{
          currentJob
          company
          position
          highlights
          startDate
          endDate
          highlights
        }
        skills{
          name
          level
          keywords
        }
      }
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The same was true for my skills section, and with this query I could simply map out my keywords. This would make adding anything in the future easier, and I could change the formatting easily without worrying about the content.&lt;/p&gt;
&lt;p&gt;I found this all to be particularly useful and it was also a great learning exercise.&lt;/p&gt;
&lt;h4&gt;Hosting with Github Pages&lt;/h4&gt;
&lt;p&gt;Publishing to Github Pages was pretty simple. My only logistical problem was how I should separate my build from my development repository. My workflow for this was probably not the most ideal but I would mirror my dev repo to my build repo, run my build, and then push to Github pages with the npm gh-pages library. This process pretty simple. My only problem was when I would have React apps on github pages when they in their own repo. For example my finance app at alex-love.github.io/finance-app&lt;/p&gt;
&lt;p&gt;Initially I ran into some trouble with my client-side routing, as my application was behaving as if it was at the root directory.&lt;/p&gt;
&lt;p&gt;This fix for this was pretty simple, I just had to add&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;quot;homepage&amp;quot;: &amp;quot;https://alex-love.github.io/finance-app&amp;quot;,&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;in my package.json as well as&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;BrowserRouter basename={process.env.PUBLIC_URL}&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;in my BrowserRouter. This basename allows my app to be served off the project sub-directory.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Reflections on my learning process: Programming and Computer Science]]></title><description><![CDATA[My History With CS and ProgrammingIt all began when I was a Junior in high school. Growing up, I spend a fair bit of time near computers. My…]]></description><link>http://alex-love.github.io/reflections-on-the-process/</link><guid isPermaLink="false">http://alex-love.github.io/reflections-on-the-process/</guid><pubDate>Tue, 19 Mar 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;My History With CS and Programming&lt;/h2&gt;
&lt;p&gt;It all began when I was a Junior in high school. Growing up, I spend a fair bit of time near computers. My Dad worked in software, so we always have a new computer around (always Macs). This created an interest in technology for me early on, and that interest still exists today. I’ll admit, the tech-centric mind of silicon valley contributed an indirect external pressure that I still don’t quite understand.&lt;/p&gt;
&lt;p&gt;At a certain point, I decided to enroll in a CS course in high-school. I think it was initially motivated by my Dad, but I don’t regret taking it. While my school was located in the heart of silicon valley (Palo Alto), we wouldn’t have an actual CS teacher at my school until the following year. For my first class it was just a proctor that oversaw us taking online community college classes. In total, I took 2 quarters worth of introductory CS classes for the year. They were taught in JAVA and progressed us through the basics of programming and more specifically, OOP/Events in JAVA. &lt;/p&gt;
&lt;h3&gt;My Initial Thoughts&lt;/h3&gt;
&lt;p&gt;Initially, nothing made sense. From my knowledge, we were writting basic code that was then compiled, which my computer would then ‘run’/interpret. These programs would usually output to the System, or when we got a little more advanced, display some data or text on a Swing panel/frame and possibly have a few editable fields with events tied to them. For me to truly learn something, I want to understand it on a fundamental level, at least conceptually. I also felt a strong sense of competitiveness between my peers and judged myself harshly for my perceived lack of knowledge. &lt;/p&gt;
&lt;p&gt;Initially I was interested, but I was deeply lost in the bigger picture. I felt insuperior to my seemingly smarter and more knowledgeable peers. My interest was there, but at the same time it was also being crushed by the feeling that trying to learn about this stuff was a lost cause for myself. &lt;strong&gt;&lt;em&gt;What I didn’t realize at the time was that a lot of my fellow classmates had parents who were engineers that were assisting them and tutoring them. More importantly, I later realized that I should focus on myself and not compare myself to others in that way.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Some more advanced students around me were writing applications or more complex code, but I was limited to writing small example programs such as sorting algorithms from our coursework, or small text games. I knew that in order to do something more sophisticated there was a lot to learn, but I lacked a sense of direction and was unsure of what small steps in my learning I would need to take to one day make my own Apps or other pieces of software. I had a desire to build high quality software, but felt like I was decades away from the knowledge to do so. While discouraged, I still enrolled in APCS for the following school year.&lt;/p&gt;
&lt;h3&gt;APCS&lt;/h3&gt;
&lt;p&gt;My APCS course was largely useless in terms of direct learning. Whenever I have a bad/negative experience with something, I like to think about what I learned in regards to why I perceived the experience as negative. If I was the teacher, how would I have done things differently? With my further knowledge now, how would I have approached my learning differently? I’ll answer these questions soon.&lt;/p&gt;
&lt;h4&gt;Why the course was poorly taught&lt;/h4&gt;
&lt;p&gt;For context, my teacher was a proclaimed MIT PhD holder, he made sure to mention it to us. While his qualifications are largely irrelevent, they can perhaps provide some context into why he taught the course how he did. &lt;/p&gt;
&lt;p&gt;In general, we did not follow any conventional APCS curriculum, my teacher focused largely on advanced data structures such as trees, hashtables, etc… and neglected any standard curriculum. My first couple assignments in the class were to program some scalable visual graphics in Java’s standard swing library. He seemed to be concerned with trying to expose us to advanced material when we didn’t even know how to apply the more basic principles from the previous years coursework. Not to mention that we didn’t even discuss any of the basic, very important fundamentals of programming.&lt;/p&gt;
&lt;p&gt;So not only was I still lacking a general sense of direction or purpose for what I was learning, but I was only being thrust deeper into the rabbit hole, furthering my sense of self doubt and confusion. &lt;/p&gt;
&lt;h4&gt;What would I have done differently as teacher?&lt;/h4&gt;
&lt;p&gt;I think what would have helped me the most in my early stages of learning, would be to start creating programs early on. It’s important to learn from your mistakes, or find the need of a concept through your own projects. We got so dirty in the time complexity of algorithms (this was in highschool) before we even knew the motivation of such endevours. If we aren’t even close to capable of writing an application at scale that will benefit from performance optimization, what is the point of diving into math and algorithms that often aren’t taught until later in college? (I took a course on this sophomore year of college).&lt;/p&gt;
&lt;p&gt;If you want to motivate a student to learn as opposed to memorize, you need to inspire their curiousity and let the learning occur naturally. My most productive computer science learning has been through trying to solve and optimize my own problems in personal projects, not trying to implement an algorithm from a textbook. I appreciate and understand the usefullness, but early on students just need to code, learn from their mistakes, and apply the knowledge and concepts that they know so far. This inspires curiousity and further learning and also provides context and motivation for any previous learning. &lt;/p&gt;
&lt;p&gt;I also would have tried to teach the APCS curriculum. My class was essentially handed a test prep book a week or two before the exam and told to prepare for it. This led me to scoring a 3 on the exam which made me unable to recieve college credit. This required me to take intro CS again in college which ultimately was a poor use of my time. &lt;/p&gt;
&lt;h4&gt;How would I have liked to learn the material?&lt;/h4&gt;
&lt;p&gt;I think applied learning is one of the most fun and efficient ways to learn CS and programming. Whenever I work on a personal project, I usually learn a lot because one question leads to another. I try to solve one problem and realize that I need to know 3 different things which each require their own set of requirements themselves. While it can easily spiral out of control and lead you in an endless cycle of learning, simple projects are often able to teach you a lot while remainly less complex. I think well thought out projects that have just enough guidance to point you in the right direction would be beneficial to the learning of someone at any skill level.&lt;/p&gt;
&lt;p&gt;Personally, I’ve found that it’s hard to learn something purely for the sake of learning it. I like to use what I’ve learned and I like to learn what I’ll use. For example, I’m currently working on implementing my own form of account management because I’ve always felt a lack of knowledge in using databases as well as the security aspect of it. I want to understand how to optimally use a database for this purpose. If you had asked me 3 years ago what my interest in databases was, I would have said ‘minimal’, but now that I know what I want to use it for, I’m very interested in the topic.&lt;/p&gt;
&lt;h3&gt;What I would tell a complete beginner&lt;/h3&gt;
&lt;p&gt;If I could talk to my younger self I would say something along these lines:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Don’t compare yourself to others. At the end of the day all that matters is that you are progressing and learning. Someones always going to know more than you, but you can continue to learn. Only when you quit do you fail. It may take you 2 years to learn something that only took someone else 1 month, but as long as you don’t quit you will still get there. Make sure that you are learning through purpose and curiosity. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;It’s important to have fun. Don’t do this just because you think you should. Do it because you want to. Do it because you are curious. Do it because you want to solve a problem, or make a game/app for your friends.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Some of this won’t make sense for a while. It may feel like you are learning something you’ll never use or fully understand, but eventually you will look back and realize the importance. Sometimes you won’t be able to immediately put the pieces together, but sometimes immediately putting the pieces together simply isn’t possible. Assuming you stick with it, you will look back and be proud of how far you have come, how much you now understand what once made no sense to you. You’ll still think you have so far to go, but you’re a lot closer than where you started purely because you stuck with it. Only if you quit would you have stopped learning.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;If you truly want to learn and become a better programmer, you need to work on it consistently. You also need to work on your own projects and write your own code. It’s easy to get stuck in a viscious cycle of following tutorials or reading on concepts. The sooner you get to making your own stuff, the quicker you will learn.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Why I changed my major after 2 years of CS in college&lt;/h3&gt;
&lt;p&gt;In college I switched from being a CS major to an Econ major after 2 years. I was frustrated with the quality of the courses I was taking and annoyed that we never had any actual projects in any of my classes. My curiosity was beginning to fizzle, and I was deeply interested in the questions that Economics proposed. I felt that my time and intellectual curiosity would better be spent studying Economics. &lt;/p&gt;
&lt;p&gt;While this journey of learning has been long and confusing, ultimately I believe I made the correct choice. Studying Economics really helped advance my critical thinking and the way I solve and analyze a problem. At the same time, my CS experience was very useful in my problem solving process. I think the two went very well together for me and I left college feeling like I had learned quite a bit. &lt;/p&gt;
&lt;p&gt;At some point I would like to finish a CS degree, or pursue an advanced degree. Ultimately I was only about 2-3 semesters away from a traditional CS degree. While I feel like I have learned far more outside of college, there are still a few subjects that I believe formal coursework would benefit me, those being: operating systems, databases, and networking. I think some foundational knowledge in those subjects would benefit me and I intent to take courses if I find the right opportunity. &lt;/p&gt;
&lt;h3&gt;Final Reflection&lt;/h3&gt;
&lt;p&gt;My biggest struggle with programming is feeling like I’m learning too slowly. I think the easiest way for me to alleviate this concern is to look back at how far my knowledge has progressed since the previous period. For this post I’ll highlight the skills that I have learned since graduating college. While I don’t claim to be an expert in any of these skills, I’ve at least exposed myself to them.&lt;/p&gt;
&lt;h4&gt;HTML,CSS,JS&lt;/h4&gt;
&lt;p&gt;I’ve been working on websites and have really advanced my knowledge in these core web technologies. While I still feel like I have a lot to learn for all of them, I have a much better understanding of how the web works at a core level.&lt;/p&gt;
&lt;h4&gt;Wordpress and webhosting&lt;/h4&gt;
&lt;p&gt;At my job, I’ve worked with wordpress a lot. Personally I’ve noticed a lot of problems with our use of it and find that Wordpress sites often become outdated and full of bloat plugins and uncontrollable dependencies. Being relient on third-party plugins has always been a concern of mine. I also find that Wordpress often results in a lot of bottlenecking through db queries which has motivated me to learning about static-site generators, such as my website. &lt;/p&gt;
&lt;h4&gt;Git&lt;/h4&gt;
&lt;p&gt;In my personal projects I always use git for version control. I really only do basic operations and feature branching, since I am a one man show, but I have found the knowledge immensely useful for my develop workflow. &lt;/p&gt;
&lt;h4&gt;NPM/package managers&lt;/h4&gt;
&lt;p&gt;Package managers have been a gamechanger for me. Having a consistent environment/dependency structure has always been a confusion of mine, especially early on. Using npm has really made my life a lot easier and I use it everyday.&lt;/p&gt;
&lt;h4&gt;Node/Express, Python/Flask&lt;/h4&gt;
&lt;p&gt;The concept of web-servers was always a mystery to me. I had a general idea of what they were, but I really had no idea how they worked on a base level, or even in terms of implementation. I’ve spun up a few basic APIs with both express/flask and it really elevated my learning and understanding. &lt;/p&gt;
&lt;h4&gt;React&lt;/h4&gt;
&lt;p&gt;I’m still learning React, but it’s really helped me resolve my concern of how to implement web apps well. I like the component structure it provides and the lifecycle methods have been useful to me. I’ve been using it mostly out of curiousity as opposed to necessity, but I think it has improved my JS skills as well. I’ve made simple flashcard app that randomly displays GRE test words that I initially scraped from a website using Python.&lt;/p&gt;</content:encoded></item></channel></rss>